#ifndef _SEMANTICS_OF_CONSTRUCTORS__DEFAULT_CONSTRUCTORS_H_
#define _SEMANTICS_OF_CONSTRUCTORS__DEFAULT_CONSTRUCTORS_H_


#include <iostream>


/**
 * The Semantics of Constructors
 */
namespace SemanticsOfConstructors {

    /**
     * default constructors that initializes its members
     *   1. A program's need for a default constructor is the responsibility of the programmer (explicit default constructor);
     *   2. A implementation's need for a default constructor is the responsibility of the compiler (implicit default constructor);
     *   NOTE:
     *     a) Global objects are guaranteed to have their associated memory "zeroed out" at program start-up.
     *     b) Local objects allocated on the program stack and heap objects allocated on the free-store
     *        do not have their associated memory zeroed out.
     */
    namespace DefaultConstructor {

        class Foo {
        public:
            // default constructors regenerated by the compiler don't initializes its two members to zero.
            // the designer of class Foo needs to provide an explicit default constructor that properly
            // initializes the class's two members.
            Foo() {
                val = 0;
                pnext = NULL;
            }
            int val;
            Foo *pnext;
        };

        void foo_bar() {
            // Oops: program needs bar's members zeroed out
            Foo bar;
            if (bar.val || bar.pnext) {
                // ... do something
            }
        }

    } // namespace DefaultConstructor


    /**
     * the four conditions under which the implicit default constructor is nontrivial
     *   The standard then goes on to iterate the conditions under which the implicit default constructor is
     *   considered trivial. A nontrivial default constructor is one that in the ARM's terminology is needed by
     *   the implementation and, if necessary, is synthesized by the compiler.
     *   NOTE:
     *     In practice, trivial default constructors are not synthesized.
     */
    namespace NontrivialDefaultConstructor {

        /**
         * Member Class Object with Default Constructor
         *   If a class without any constructors contains a member object of a class with a default constructor,
         *   the implicit default constructor of the class is nontrivial and the compiler needs to synthesize a
         *   default constructor for the containing class. This synthesis, however, takes place only if the
         *   constructor actually needs to be invoked.
         */
        namespace ConditionOne {

            // single class member objects requiring constructor initialization
            class Foo { public: Foo() {} };
            class Bar { public: Foo foo; };

#ifdef AUTO_TRANSFORM_BY_COMPILER
            // possible synthesis of Bar default constructor
            // invoke Foo default constructor for member foo
            inline Bar::Bar() {
                // Pseudo C++ Code
                foo.Foo::Foo();
            }
#endif

            void foo_bar() {
                Bar bar; // Bar::foo must be initialized here
            }

            // multiple class member objects requiring constructor initialization
            //   The language requires that the constructors be invoked in the order of member declaration within the class.
            class Dopey { public: Dopey() {} };
            class Sneezy { public: Sneezy(int) {} };
            class Bashful { public: Bashful() {} };

            class Snow_White {
            public:
                Snow_White();
                Dopey dopey;
                Sneezy sneezy;
                Bashful bashful;

            private:
                int mumble;
            };

            // programmer coded default constructor
            Snow_White::Snow_White() : sneezy(1024) {
                mumble = 2048;
            }

#ifdef AUTO_TRANSFORM_BY_COMPILER
            // Compiler augmented default constructor
            // Pseudo C++ Code
            Snow_White::Snow_White() {
                // insertion of member class object
                // constructor invocations
                dopey.Dopey::Dopey();
                sneezy.Sneezy::Sneezy(1024);
                bashful.Bashful::Bashful();
                // explicit user code
                mumble = 2048;
            }
#endif

        } // namespace ConditionOne

        /**
         * Base Class with Default Constructor
         *   Similarly, if a class without any constructors is derived from a base class containing a default constructor,
         *   the default constructor for the derived class is considered nontrivial and so needs to be synthesized.
         *   The synthesized default constructor of the derived class invokes the default constructor of each of its
         *   immediate base classes in the order of their declaration.
         *   NOTE:
         *     If member class objects with default constructors are also present, these default constructors are also
         *     invoked¡ª¡ªafter the invocation of all base class constructors.
         */
        namespace ConditionTwo {
        } // namespace ConditionTwo

        /**
         * Class with a Virtual Function
         *   There are two additional cases in which a synthesized default constructor is needed:
         *   1. The class either declares (or inherits) a virtual function
         *   2. The class is derived from an inheritance chain in which one or more base classes are virtual
         */
        namespace ConditionThree {

            class Widget {
            public:
                virtual void flip() const = 0;
            };

            class Bell : public Widget {
            public:
                void flip() const {}
            };

            class Whistle : public Widget {
            public:
                void flip() const {}
            };

            void flip(const Widget& widget) { widget.flip(); }

#ifdef AUTO_TRANSFORM_BY_COMPILER
            void flip(const Widget& widget) {
                // simplified transformation of virtual invocation:
                //   > 1 represents flip()'s fixed index into the virtual table;
                //   > &widget represents the this pointer to be passed to the particular invocation of flip().
                (*widget.vptr[1]) (&widget)
            }
#endif

            void foo() {
                Bell b;
                Whistle w;
                flip(b);
                flip(w);
            }

        } // namespace ConditionThree

        /**
         * Class with a Virtual Base Class
         *   Virtual base class implementations vary widely across compilers. However, what is common to each
         *   implementation is the need to make the virtual base class location within each derived class object
         *   available at runtime.
         */
        namespace ConditionFour {

            class X { public: int i; };
            class A : public virtual X { public: int j; };
            class B : public virtual X { public: double d; };
            class C : public A, public B { public: int k; };

            // the compiler cannot fix the physical offset of X::i accessed through pa within foo(), 
            // since the actual type of pa can vary with each of foo()'s invocations. Rather, the compiler
            // must transform the code doing the access so that the resolution of X::i can be delayed until runtime.
            void foo(A* const pa) { pa->i = 1024; }

#ifdef AUTO_TRANSFORM_BY_COMPILER
            // possible compiler transformation
            void foo(A* const pa) { pa->__vbcX->i = 1024; }
#endif

            void do_foo() {
                foo(new A);
                foo(new C);
            }

        } // namespace ConditionFour

    } // namespace NontrivialDefaultConstructor

} // namespace SemanticsOfConstructors


#endif // _SEMANTICS_OF_CONSTRUCTORS__DEFAULT_CONSTRUCTORS_H_

